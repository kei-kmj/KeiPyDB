<style>
h1, h2, h3, h4, h5, h6, p, span, div, li, td, th {
  color: #454554 !important;
}
.slidev-page-number {
  position: absolute;
  bottom: 0;
  width: 100%;
  text-align: center;
  color: #888;
  font-size: 0.85rem;
}
.slidev-presenter-note {
  background-color: white !important;
  color: black !important;
}
</style>

<!-- タイトル -->

# Python製RDBMSで理解する、<br>データベースのピース
## コードのステップ実行とヘックスビューアーで<br>内部動作を追ってみよう

PyCon JP 2025 →
<br>
@Keiko Kamijo

---

<!-- Page 1 自己紹介-->
# 自己紹介
## 名前：上條　恵子

## 所属：株式会社Delta-x
<div class="slidev-page-number">1</div>

---

<!-- Page 2 塾選-->
<style scoped>
.slidev-layout {
  padding: 0 !important;
}
</style>

<img src="/bestjuku.png" style="position: absolute; top: 0; left: 0; right: 0; bottom: 30px; width: 100%; height: calc(100% - 30px); object-fit: contain;" />

<div class="slidev-page-number">2</div>

---

<!-- Page 3 CMスクショ-->
<style scoped>
.slidev-layout {
  padding: 0 !important;
}
</style>

<img src="/cm.png" style="position: absolute; top: 0; left: 0; right: 0; bottom: 30px; width: 100%; height: calc(100% - 30px); object-fit: contain;" />

<div class="slidev-page-number">3</div>

---

<!-- Page 4 本題-->
## データベースの重要性
- 大抵のサービスでデータは重要な資産
<br>
- データを管理するシステム = データベースが必要
<br>

##  データベースの種類

- RDB → PostgreSQL, MySQL
- NoSQL → MongoDB, Redis
- グラフDB → Neo4j

<br>

## 今日のテーマ：RDBMS
### Relational Database Management System

- データを**表（テーブル）**で管理
- SQLで操作
- ACID特性を保証（原子性・一貫性・隔離性・永続性）




---

<!-- Page 5 話さないこと None Goal-->
# 話すこと/話さないこと Goal/None Goal
<div style="margin: 40px auto; max-width: 800px;">
<table style="width: 100%; border-collapse: collapse; font-size: 18px;">
<tr>
<td style="border: 2px solid #333; padding: 20px; background: #e8f5e9; width: 50%; vertical-align: top;">
<strong style="color: #2e7d32;">✅ 話すこと</strong><br><br>
- RDBMSのアーキテクチャ<br>
- RDBMSの処理フロー
</td>
<td style="border: 2px solid #333; padding: 20px; background: #ffebee; width: 50%; vertical-align: top;">
<strong style="color: #c62828;">❌ 話さないこと</strong><br><br>
- SQLの文法やクエリの書き方<br>
- 特定のデータベース製品の内容や使い方<br>
- C言語との比較
</td>
</tr>
<tr>
<td style="border: 2px solid #333; padding: 20px; background: #e3f2fd; vertical-align: top;">
<strong style="color: #1565c0;">🎯 Goal</strong><br><br>
- RDBMSの内部動作を理解する
</td>
<td style="border: 2px solid #333; padding: 20px; background: #fff3e0; vertical-align: top;">
<strong style="color: #e65100;">🚫 Non Goal</strong><br><br>
- 難しいSQLが書けるようになる<br>
- 特定のRDBMSの使い方をマスターする<br>
- インデックス戦略を立てられるようになる<br>
- パフォーマンスチューニングができるようになる
</td>
</tr>
</table>
</div>



<div class="slidev-page-number">5</div>

---

<!-- Page 6 RDBMSのアーキテクチャ-->
RDBMSのアーキテクチャ
一般的なRDBMSの構成要素
<br>

Lexer（字句解析） → Parser（構文解析） → Optimizer（最適化） → Planner（実行計画）

Buffer Pool（バッファ管理） → File I/O（ファイル入出力)


<div class="slidev-page-number">6</div>

---
layout: two-cols
---
<!-- Page 7 -->

# RDBMSのアーキテクチャ
<style scoped>
.col-left {
  padding-right: 1rem;
  width: 230px;
}
.col-left pre {
  background-color: white !important;
  color: black !important;
  padding: 1rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.col-right {
  padding-left: 1rem;
  width: 530px;
}
table {
  font-size: 0.85rem;
  width: 100%;
}
td, th {
  padding: 0.5rem 1rem;
  line-height: 1.8;
}
</style>

<div class="col-left">

```
┌─────────────────────┐
│    SQL Query        │
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│     Parser          │
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│     Planner         │
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│     Executor        │   
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│   Buffer Manager    │
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│   File Manager      │
└─────────────────────┘
```

</div>

::right::
<div class="col-right">
<br>
<br>

#### Parser: 
- 字句解析（Lexer）, 構文解析（Parser）

<br>

#### Planner:
- 実行計画の作成 , クエリの最適化

<br>

#### Executor: 
- クエリの実行

<br>

#### Buffer Manager: 
- メモリ内のデータ管理 , キャッシュ制御

<br>

#### File Manager: 
- データの永続化 , ファイルI/O

</div>
<div class="slidev-page-number">7</div>

---

<!-- Page 8 -->
<!--
スピーカーノート：
- 「SQLのリクエストを受け取って、最初に行われるのが字句解析です」
- 「バイト列を意味ある単位でトークンに変換します」
- 「例えば、SELECTという6文字は、一つのキーワードとして認識されます」
- トークンの種類を簡単に説明
  - キーワード：SQLの予約語
  - 識別子：テーブル名やカラム名
  - リテラル：実際の値（"Alice"のような文字列）
- デモの準備：PyCharmでtokenize関数にブレークポイントを設定
-->
SELECT文の字句解析
<style scoped>
.col-left pre {
  background-color: white !important;
  color: black !important;
  padding: 1rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  font-size: 1.2em;
}
.token-box {
  display: inline-block;
  background-color: #f0f0f0;
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 4px 8px;
  margin: 2px;
  font-family: monospace;
}
</style>
<div class="col-left">
入力SQL
```
SELECT id, name FROM users WHERE name = "alice";
```
↓ Lexer（字句解析）
<div style="margin-top: 20px;">
<span class="token-box">SELECT</span>
<span class="token-box">id</span>
<span class="token-box">,</span>
<span class="token-box">name</span>
<span class="token-box">FROM</span>
<span class="token-box">users</span>
<span class="token-box">WHERE</span>
<span class="token-box">name</span>
<span class="token-box">=</span>
<span class="token-box">"alice"</span>
<span class="token-box">;</span>
</div>
</div>
字句解析（Lexer）とは？
文字列をトークン(意味のある単語)に分解

キーワード（SELECT, FROM, WHERE）
識別子（name, age, users）
演算子（>, =, <>）
リテラル（25, 'Alice'）
区切り文字（,, ;）
<div class="slidev-page-number">8</div>

---

<!-- Page 9 -->
<!--
スピーカーノート：
- 「字句解析でトークンに分解したら、次は構文解析です」
- 「バラバラのトークンを、SQLの文法に従って構造化します」
- 「これを抽象構文木（AST）と呼びます」
「構文解析の本来の役割は、トークン列をAST（抽象構文木）に変換することです」
- 「本格的なデータベースでは、SQLの構造を完全な木構造で表現します」
- 右上の図で木構造を説明
- 「完全なASTではないけれど、パーサーがやるべきこと（構文を解析して構造化する）の本質は同じです」
-->
SELECT文の構文解析
<style scoped>
.col-left pre {
  background-color: white !important;
  color: black !important;
  padding: 1rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.tree-node {
  margin-left: 20px;
  font-family: monospace;
  line-height: 1.8;
}
</style>
<div class="col-left">
トークン列
```
SELECT, id, ,, name, 
FROM, users, 
WHERE, name, =, "Alice", ;
```
Parser（構文解析）
<div style="background-color: white; padding: 1rem; border-radius: 8px; margin-top: 20px;">
<div style="font-family: monospace; font-size: 0.9em;">
SelectStatement   
```
├─ SelectClause   
│   ├─ Column("id")   
│   └─ Column("name")   
├─ FromClause   
│   └─ Table("users")   
└─ WhereClause
    └─ BinaryExpression
        ├─ left: Column("name")
        ├─ operator: "="
        └─ right: Literal("Alice")
```
</div>
</div>
<br>

</div>
::right::
構文解析（Parser）とは？
トークン列をAST（抽象構文木）に変換
本格的なDBでは完全な木構造：
```
     SELECT文
    /    |    \
  列名  FROM   WHERE
        |       |
      テーブル  条件式
```



<div class="slidev-page-number">9</div>

---

<!-- Page 10 -->


# Plannerから実行エンジン
<div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
<div style="font-family: monospace; background: white; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
SELECT id, name FROM users WHERE name = "Alice"
</div>
<div style="display: flex; justify-content: space-between; align-items: flex-start;">
<div style="flex: 1; margin-right: 20px;">
<strong>宣言的</strong><br>
「Aliceのデータが欲しい」
</div>
<div style="flex: 2;">
<strong>→ Plannerが実行計画を作成</strong><br>
<div style="margin-top: 10px; padding: 10px; background: #e3f2fd; border-radius: 5px;">
TableScan + WHERE条件フィルタ
</div>
<strong style="margin-top: 15px; display: block;">→ 実行エンジン</strong>
<div style="margin-top: 10px; padding-left: 20px;">
1. トランザクション開始<br>
2. users.tblファイルを開く<br>
3. 一定の単位（ブロック）でファイルを読み込んでフィルター<br>
4. 次のブロックへ...<br>
5. 結果: [(2, "Alice")]
</div>
</div>
</div>
</div>


<div class="slidev-page-number">10</div>

---

<!-- Page 11 -->
SELECT処理のまとめ
今見てきたこと
<div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
<div style="font-family: monospace; background: white; padding: 10px; margin-bottom: 20px; border-radius: 5px;">
SELECT id, name FROM users WHERE name = "Alice"
</div>
<div style="padding: 0 20px;">
<strong>ステップ実行で確認できたこと：</strong>
<div style="margin: 15px 0;">
✓ <strong>字句解析</strong>で文字列がトークンに分解される様子
</div>
<div style="margin: 15px 0;">
✓ <strong>構文解析</strong>でASTが構築されていく過程
</div>
<div style="margin: 15px 0;">
✓ <strong>Planner</strong>が実行計画を作成する流れ
</div>
<div style="margin: 15px 0;">
✓ <strong>実行エンジン</strong>がトランザクション経由で<br>
&nbsp;&nbsp;&nbsp;&nbsp;実際にファイルを読み込む動作
</div>
<div style="margin: 15px 0;">
✓ <strong>ブロック単位</strong>でデータを読み込み、<br>
&nbsp;&nbsp;&nbsp;&nbsp;WHERE条件でフィルタする処理
</div>
</div>
</div>

<div class="slidev-page-number">11</div>

---

<!-- Page 12 -->

# データの永続化
SELECT文で、レコードを取得する流れを見てきました。
でも、ちょっと待って... 🤔
<div style="background: #fff3e0; padding: 20px; border-radius: 8px; margin: 20px 0;">
<div style="text-align: center; font-size: 24px; margin: 20px 0;">
そもそも、データはどうやって<br>
ファイルに入ったの？
</div>
</div>
メモリ vs ファイル
<div style="display: flex; justify-content: space-around; margin: 20px 0;">
<div style="background: #ffebee; padding: 20px; border-radius: 8px; width: 45%;">
<strong>メモリ上のデータ</strong><br>
- 高速アクセス<br>
- 電源OFF → <span style="color: red;">消える！</span>
</div>
<div style="background: #e8f5e9; padding: 20px; border-radius: 8px; width: 45%;">
<strong>ファイルのデータ</strong><br>
- 低速アクセス<br>
- 電源OFF → <span style="color: green;">残る！</span>
</div>
</div>
データベースは永続化が必須 → ファイルに保存する必要がある

<div class="slidev-page-number">12</div>

---

<!-- Page 13 -->
# ファイルアクセス
データベースは、ファイルにデータを永続化するための仕組みを持っています。
<div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
<div style="text-align: center;">
<div style="margin: 15px 0;">
<strong>アプリケーション層</strong><br>
INSERT INTO users (id, name) VALUES (3, "Bob")
</div>
↓
<div style="margin: 15px 0;">
<strong>トランザクション層</strong><br>
同時実行制御・ACID特性の保証
</div>
↓
<div style="margin: 15px 0;">
<strong>バッファ管理層</strong><br>
メモリとディスクの橋渡し
</div>
↓
<div style="margin: 15px 0;">
<strong>ファイルI/O層</strong><br>
実際のファイル読み書き
</div>
↓
<div style="margin: 15px 0; background: #e8f5e9; padding: 10px; border-radius: 5px;">
<strong>users.tbl</strong><br>
物理ファイル（バイナリデータ）
</div>
</div>
</div>
ポイント

ブロック単位: 1レコードずつではなく、ブロック（例: 8KB）単位で読み書き
バッファリング: 頻繁なディスクアクセスを避けるためメモリにキャッシュ
トランザクション経由: 一貫性を保つため必ずトランザクション内で実行
<div class="slidev-page-number">13</div>

---

<!-- Page 14 -->
INSERT文の実行フロー
<div style="font-family: monospace; background: white; padding: 10px; border-radius: 5px; margin: 10px 0;">
INSERT INTO users (id, name) VALUES (3, "Bob")
</div>
<div style="display: flex; justify-content: space-around; margin: 15px 0;">
<div style="background: #fff3e0; padding: 15px; border-radius: 8px; width: 45%;">
<strong>データの変換</strong><br><br>
VALUES (3, "Bob")<br>
↓<br>
<div style="margin-top: 10px; font-size: 14px;">
- id: 3 → <code>00 00 00 03</code><br>
- name: "Bob" → <code>03 42 6F 62</code><br>
&nbsp;&nbsp;(長さ3 + "Bob")

</div>
</div>
<div style="background: #e3f2fd; padding: 15px; border-radius: 8px; width: 45%;">
<strong>書き込みの流れ</strong><br><br>
1. ファイルの空き領域を探す<br>
2. データをバイナリに変換<br>
3. メモリ上のバッファに書く<br>
4. 定期的にファイルに反映
</div>
</div>
<div style="background: #e8f5e9; padding: 10px; border-radius: 5px; font-family: monospace; margin: 15px 0; text-align: center; font-size: 14px;">
users.tbl: [データ][データ][<span style="color: red;">新データ</span>][空き領域...]
</div>
<div style="text-align: center; font-size: 16px;">
すべてのデータは最終的にバイナリとしてファイルに保存される
</div>




<div class="slidev-page-number">14</div>

---

<!-- Page 15 -->
# ヘックスビューアー：バイナリファイルを見るツール
<div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
<div style="text-align: center; margin-bottom: 20px;">
<strong>ヘックスビューアーで users.tbl を開くと...</strong>
</div>
<div style="font-family: monospace; background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 5px;">
<div style="display: flex; justify-content: space-between;">
<div style="flex: 1;">
<span style="color: #569cd6;">00000000:</span> 00 00 00 01 05 41 6C 69 63 65 00 00 00 02 05<br>
<span style="color: #569cd6;">00000010:</span> 43 61 72 6F 6C 00 00 00 03 03 42 6F 62 00 00<br>
<span style="color: #569cd6;">00000020:</span> 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
</div>
<div style="flex: 0.5; text-align: right; color: #ce9178;">
.....Alice.....<br>
Carol....Bob..<br>
...............
</div>
</div>
</div>
</div>
読み方
<div style="display: flex; justify-content: space-around; margin: 20px 0;">
<div style="background: #e3f2fd; padding: 15px; border-radius: 8px; width: 30%;">
<strong>アドレス</strong><br>
ファイル内の位置<br>
<code>00000000:</code>
</div>
<div style="background: #fff3e0; padding: 15px; border-radius: 8px; width: 30%;">
<strong>16進数表示</strong><br>
実際のバイナリデータ<br>
<code>00 00 00 01</code>
</div>
<div style="background: #e8f5e9; padding: 15px; border-radius: 8px; width: 30%;">
<strong>ASCII表示</strong><br>
文字として解釈<br>
<code>Alice</code>
</div>
</div>
これで実際のファイルI/Oの結果を確認できる！
<div class="slidev-page-number">15</div>

---

<!-- Page 16 -->
# ファイルI/Oのまとめ

<div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
<div style="margin-bottom: 20px;">
<strong>INSERT実行前後のファイルの変化</strong>
</div>
<div style="display: flex; justify-content: space-around;">
<div style="background: white; padding: 15px; border-radius: 5px; width: 45%;">
<strong>Before INSERT</strong><br>
<div style="font-family: monospace; font-size: 14px; margin-top: 10px;">
00000000: 00 00 00 01 05 41 6C 69 63 65<br>
00000010: 00 00 00 02 05 43 61 72 6F 6C
</div>
</div>
<div style="background: white; padding: 15px; border-radius: 5px; width: 45%;">
<strong>After INSERT</strong><br>
<div style="font-family: monospace; font-size: 14px; margin-top: 10px;">
00000000: 00 00 00 01 05 41 6C 69 63 65<br>
00000010: 00 00 00 02 05 43 61 72 6F 6C<br>
<span style="color: red;">00000020: 00 00 00 03 03 42 6F 62</span>
</div>
</div>
</div>
</div>
わかったこと
✓ データは全てバイナリ形式で保存

整数: 固定長（4バイト）
文字列: 長さ + データ

✓ ファイルへの書き込みは効率的に

ブロック単位でアクセス
バッファリングで高速化
トランザクションで一貫性保証

✓ ヘックスビューアーで中身を確認可能
<div class="slidev-page-number">16</div>

---

<!-- Page 17 -->
# エンディアン
<div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
<div style="text-align: center; margin-bottom: 20px;">
<strong>32ビット整数 0x12345678 をメモリに格納</strong>
</div>
<table style="margin: 0 auto; border-collapse: collapse;">
<tr>
<th style="padding: 10px; border: 1px solid #ccc;">アドレス</th>
<th style="padding: 10px; border: 1px solid #ccc;">+0</th>
<th style="padding: 10px; border: 1px solid #ccc;">+1</th>
<th style="padding: 10px; border: 1px solid #ccc;">+2</th>
<th style="padding: 10px; border: 1px solid #ccc;">+3</th>
</tr>
<tr>
<td style="padding: 10px; border: 1px solid #ccc;"><strong>ビッグエンディアン</strong></td>
<td style="padding: 10px; border: 1px solid #ccc; font-family: monospace;">0x12</td>
<td style="padding: 10px; border: 1px solid #ccc; font-family: monospace;">0x34</td>
<td style="padding: 10px; border: 1px solid #ccc; font-family: monospace;">0x56</td>
<td style="padding: 10px; border: 1px solid #ccc; font-family: monospace;">0x78</td>
</tr>
<tr>
<td style="padding: 10px; border: 1px solid #ccc;"><strong>リトルエンディアン</strong></td>
<td style="padding: 10px; border: 1px solid #ccc; font-family: monospace;">0x78</td>
<td style="padding: 10px; border: 1px solid #ccc; font-family: monospace;">0x56</td>
<td style="padding: 10px; border: 1px solid #ccc; font-family: monospace;">0x34</td>
<td style="padding: 10px; border: 1px solid #ccc; font-family: monospace;">0x12</td>
</tr>
</table>
</div>
なぜこんな違いが？
ビッグエンディアン

Most Significant Byte（最上位バイト）を最初に格納
ネットワークバイトオーダー（標準）
人間が数値を読む順序と同じ

リトルエンディアン

Least Significant Byte（最下位バイト）を最初に格納
x86/x64 CPUの標準
演算回路の実装が簡単（キャリー伝播）

<div class="slidev-page-number">17</div>

---

<!-- Page 18 -->
<div style="background: #ffebee; padding: 20px; border-radius: 8px; margin: 20px 0;">
```python
# 実験してみよう
with open('test.db', 'wb') as f:
    f.write(12345)  # ❌ TypeError!
```
<strong>エラーの理由</strong>
TypeError: a bytes-like object is required, not 'int'
<div style="margin-top: 15px;">
- ファイルは<strong>バイト列しか</strong>理解できない<br>
- Pythonの整数は<strong>オブジェクト</strong>（メタデータを含む）<br>
- 変換が必要：<code>12345</code> → <code>b'\x39\x30\x00\x00'</code>
</div>
</div>
整数のサイズの不思議
<div style="background: #e8f5e9; padding: 20px; border-radius: 8px; margin: 20px 0;">
<table style="width: 100%; border-collapse: collapse; margin: 0 auto;">
<tr style="background: #c8e6c9;">
<th style="border: 1px solid #4caf50; padding: 10px;">数値</th>
<th style="border: 1px solid #4caf50; padding: 10px;">文字列保存</th>
<th style="border: 1px solid #4caf50; padding: 10px;">サイズ</th>
<th style="border: 1px solid #4caf50; padding: 10px;">バイナリ保存</th>
<th style="border: 1px solid #4caf50; padding: 10px;">サイズ</th>
</tr>
<tr>
<td style="border: 1px solid #4caf50; padding: 10px;">1</td>
<td style="border: 1px solid #4caf50; padding: 10px; font-family: monospace;">"1"</td>
<td style="border: 1px solid #4caf50; padding: 10px;">1バイト</td>
<td style="border: 1px solid #4caf50; padding: 10px; font-family: monospace;">00 00 00 01</td>
<td style="border: 1px solid #4caf50; padding: 10px; background: #ffeb3b;"><strong>4バイト</strong></td>
</tr>
<tr>
<td style="border: 1px solid #4caf50; padding: 10px;">12345</td>
<td style="border: 1px solid #4caf50; padding: 10px; font-family: monospace;">"12345"</td>
<td style="border: 1px solid #4caf50; padding: 10px;">5バイト</td>
<td style="border: 1px solid #4caf50; padding: 10px; font-family: monospace;">00 00 30 39</td>
<td style="border: 1px solid #4caf50; padding: 10px; background: #ffeb3b;"><strong>4バイト</strong></td>
</tr>
<tr>
<td style="border: 1px solid #4caf50; padding: 10px;">2147483647</td>
<td style="border: 1px solid #4caf50; padding: 10px; font-family: monospace;">"2147483647"</td>
<td style="border: 1px solid #4caf50; padding: 10px; color: red;">10バイト</td>
<td style="border: 1px solid #4caf50; padding: 10px; font-family: monospace;">7F FF FF FF</td>
<td style="border: 1px solid #4caf50; padding: 10px; background: #ffeb3b;"><strong>4バイト</strong></td>
</tr>
</table>
<div style="text-align: center; margin-top: 15px; font-size: 20px;">
<strong>32ビット整数 = 常に4バイト固定！</strong><br>
<span style="font-size: 16px;">（0 〜 4,294,967,295 の範囲）</span>
</div>
</div>
<!-- 
スピーカーノート：
- ファイルはバイトの並びでしかない
- Pythonのオブジェクトとバイト列は別物
- 固定長の威力：インデックスが簡単、メモリ計算が容易
-->
<div class="slidev-page-number">18</div>

---

<!-- Page 19 -->

<div class="slidev-page-number">19</div>

---

<!-- Page 20 -->

<div class="slidev-page-number">20</div>

---

<!-- Page 21 -->

<div class="slidev-page-number">21</div>

---

<!-- Page 22 -->

<div class="slidev-page-number">22</div>

---

<!-- Page 23 -->

<div class="slidev-page-number">23</div>

---

<!-- Page 24 -->

<div class="slidev-page-number">24</div>

---

<!-- Page 25 -->

<div class="slidev-page-number">25</div>

---

<!-- Page 26 -->

<div class="slidev-page-number">26</div>

---

<!-- Page 27 -->

<div class="slidev-page-number">27</div>

---

<!-- Page 28 -->

<div class="slidev-page-number">28</div>

---

<!-- Page 29 -->

<div class="slidev-page-number">29</div>

---

<!-- Page 30 -->

<div class="slidev-page-number">30</div>

---

<!-- Page 31 -->

<div class="slidev-page-number">31</div>

---

<!-- Page 32 -->

<div class="slidev-page-number">32</div>

---

<!-- Page 33 -->

<div class="slidev-page-number">33</div>

---

<!-- Page 34 -->

<div class="slidev-page-number">34</div>

---

<!-- Page 35 -->

<div class="slidev-page-number">35</div>